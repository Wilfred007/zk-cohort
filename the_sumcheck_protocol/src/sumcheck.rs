
use ark_ff::{BigInteger, PrimeField};
use sha3::{Digest, Keccak256};
use multilinear::multilinear::MultilinearEvalForm;
use fiat_shamir::fiat_shamir::Transcript;
use std::marker::PhantomData;

// Represents the entity proving the correctness of a claim about a multilinear polynomial.
pub struct Prover<F: PrimeField> {
    initial_poly: MultilinearEvalForm<F>, // Holds the polynomial being proven.
    initial_claimed_sum: F, // Stores the sum of all evaluations of the polynomial.
    transcript: Transcript<F, Keccak256>, // The Fiat-Shamir transcript for generating deterministic challenges.
    round_proof_poly: Vec<MultilinearEvalForm<F>>, // Stores intermediate univariate polynomials for each round.
}

// Stores the proof generated by the prover.
pub struct Proof<F: PrimeField> {
    pub initial_poly: MultilinearEvalForm<F>,
    pub initial_claimed_sum: F,
    pub round_proof_poly: Vec<MultilinearEvalForm<F>>,
}

pub struct Verifier<F: PrimeField> {
    transcript: Transcript<F, Keccak256>,
    _phantom: PhantomData<F>,
}

fn divide_poly_and_sum<F: PrimeField>(poly_eval_values: &Vec<F>) -> Vec<F> {
    let mut univariate_poly: Vec<F> = Vec::with_capacity(2);
    let middle_point = poly_eval_values.len() / 2;
    let (left, right) = poly_eval_values.split_at(middle_point);

    let sum_left_hand: F = left.iter().sum();
    let sum_right_hand: F = right.iter().sum();

    univariate_poly.push(sum_left_hand);
    univariate_poly.push(sum_right_hand);

    univariate_poly
}

fn convert_elements_to_bytes<F: PrimeField>(field_element: F) -> Vec<u8> {
    let big_int = field_element.into_bigint();
    big_int.to_bytes_le() // Changed to little-endian for consistency
}

impl<F: PrimeField> Prover<F> {
    pub fn init(poly_eval_values: &Vec<F>) -> Self {
        let poly = MultilinearEvalForm::new(poly_eval_values);
        let transcript = Transcript::<F, Keccak256>::init(Keccak256::new());
        println!("Initial polynomial values: {:?}", poly_eval_values);

        let sum = poly_eval_values.iter().sum();
        println!("Claimed sum: {:?}", sum);

        Prover {
            initial_poly: poly,
            initial_claimed_sum: sum,
            transcript,
            round_proof_poly: Vec::new(),
        }
    }

    pub fn create_proof(&mut self) -> Proof<F> {
        self.transcript.append(&self.initial_poly.convert_to_bytes());
        self.transcript.append(&convert_elements_to_bytes(self.initial_claimed_sum));

        let mut current_poly = self.initial_poly.clone();
        println!(
            "Starting proof generation with {} variables",
            self.initial_poly.number_of_variables()
        );

        for round in 0..self.initial_poly.number_of_variables() {
            println!(
                "Round {}: Current polynomial values: {:?}",
                round, current_poly.evaluated_values
            );

            let univariate_poly_values = divide_poly_and_sum(&current_poly.evaluated_values);
            println!("Round {}: Univariate poly values: {:?}", round, univariate_poly_values);

            let univariate_poly = MultilinearEvalForm::new(&univariate_poly_values);
            let univariate_poly_in_bytes = univariate_poly.convert_to_bytes();
            self.transcript.append(&univariate_poly_in_bytes);
            self.round_proof_poly.push(univariate_poly);


            let random_challenge: F = self.transcript.hash();
            println!("Round {}: Challenge: {:?}", round, random_challenge);

            let evaluated = current_poly.partial_evaluate(round.try_into().unwrap(), random_challenge);
            current_poly = MultilinearEvalForm::new(&evaluated);
        }

        Proof {
            initial_poly: self.initial_poly.clone(),
            initial_claimed_sum: self.initial_claimed_sum,
            round_proof_poly: self.round_proof_poly.clone(),
        }
    }
}

impl<F: PrimeField> Verifier<F> {
    pub fn init() -> Self {
        Self {
            transcript: Transcript::<F, Keccak256>::init(Keccak256::new()),
            _phantom: PhantomData,
        }
    }

    pub fn verify(&mut self, proof: Proof<F>) -> bool {
        println!("Starting verification");
        println!(
            "Number of rounds in proof: {}",
            proof.round_proof_poly.len()
        );
        println!(
            "Number of variables in initial poly: {}",
            proof.initial_poly.number_of_variables()
        );

        if proof.round_proof_poly.len() != proof.initial_poly.number_of_variables().try_into().unwrap() {
            println!("Proof length mismatch!");
            return false;
        }

        let mut current_claim_sum = proof.initial_claimed_sum;
        println!("Initial claimed sum: {:?}", current_claim_sum);

        self.transcript.append(&proof.initial_poly.convert_to_bytes());
        self.transcript.append(&convert_elements_to_bytes(proof.initial_claimed_sum));

        let mut challenges: Vec<F> = Vec::with_capacity(proof.round_proof_poly.len());

        for i in 0..proof.round_proof_poly.len() {
            println!("Verifying round {}", i);
            let eval_at_zero = vec![F::zero()];
            let eval_at_one = vec![F::one()];

            let sum_at_endpoints = proof.round_proof_poly[i].evaluate(&eval_at_zero)
                + proof.round_proof_poly[i].evaluate(&eval_at_one);

            println!("Round {}: Sum at endpoints: {:?}", i, sum_at_endpoints);
            println!("Round {}: Current claim sum: {:?}", i, current_claim_sum);

            if sum_at_endpoints != current_claim_sum {
                println!("Sum check failed at round {}!", i);
                return false;
            }

            self.transcript.append(&proof.round_proof_poly[i].convert_to_bytes());

            let challenge: F = self.transcript.hash();
            println!("Round {}: Generated challenge: {:?}", i, challenge);
            challenges.push(challenge);

            current_claim_sum = proof.round_proof_poly[i].evaluate(&vec![challenge]);
            println!("Round {}: New current claim: {:?}", i, current_claim_sum);
        }

        // oracle check
        let final_evaluation = proof.initial_poly.evaluate(&challenges);
        println!("Final evaluation: {:?}", final_evaluation);
        println!("Final claim sum: {:?}", current_claim_sum);

        final_evaluation == current_claim_sum
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use ark_bn254::Fq;

    #[test]
    fn test_prover() {
        let evaluated_values = vec![Fq::from(0), Fq::from(0), Fq::from(3), Fq::from(8)];
        let prover = Prover::init(&evaluated_values);

        assert_eq!(prover.initial_claimed_sum, Fq::from(11));
        assert_eq!(prover.initial_poly.evaluated_values, evaluated_values);
    }

    #[test]
    fn test_proof_verification() {
        let evaluated_values = vec![Fq::from(0), Fq::from(0), Fq::from(3), Fq::from(8)];
        let mut prover = Prover::init(&evaluated_values);
        let proof = prover.create_proof();

        let mut verifier = Verifier::init();
        assert!(verifier.verify(proof));
    }

    #[test]
    fn test_simple_proof_verification() {
        let evaluated_values = vec![Fq::from(1), Fq::from(2)]; // Simple 1-variable case
        let mut prover = Prover::init(&evaluated_values);
        let proof = prover.create_proof();

        let mut verifier = Verifier::init();
        assert!(verifier.verify(proof));
    }
}